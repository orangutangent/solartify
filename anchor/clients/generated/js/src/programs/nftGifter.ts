/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedClaimTokensInstruction,
  type ParsedInitConfigInstruction,
  type ParsedMintNftInstruction,
  type ParsedPurchaseTokensInstruction,
  type ParsedUpdateConfigInstruction,
  type ParsedWithdrawSolInstruction,
} from '../instructions';

export const NFT_GIFTER_PROGRAM_ADDRESS =
  '5gm1Nn7N3BDn2og4Umw5JePUhLUF2azKqwJduQx3tApg' as Address<'5gm1Nn7N3BDn2og4Umw5JePUhLUF2azKqwJduQx3tApg'>;

export enum NftGifterAccount {
  Config,
  UserClaimData,
}

export function identifyNftGifterAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): NftGifterAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([155, 12, 170, 224, 30, 250, 204, 130])
      ),
      0
    )
  ) {
    return NftGifterAccount.Config;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([214, 233, 149, 224, 175, 229, 124, 134])
      ),
      0
    )
  ) {
    return NftGifterAccount.UserClaimData;
  }
  throw new Error(
    'The provided account could not be identified as a nftGifter account.'
  );
}

export enum NftGifterInstruction {
  ClaimTokens,
  InitConfig,
  MintNft,
  PurchaseTokens,
  UpdateConfig,
  WithdrawSol,
}

export function identifyNftGifterInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): NftGifterInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([108, 216, 210, 231, 0, 212, 42, 64])
      ),
      0
    )
  ) {
    return NftGifterInstruction.ClaimTokens;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([23, 235, 115, 232, 168, 96, 1, 231])
      ),
      0
    )
  ) {
    return NftGifterInstruction.InitConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([211, 57, 6, 167, 15, 219, 35, 251])
      ),
      0
    )
  ) {
    return NftGifterInstruction.MintNft;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([142, 1, 16, 160, 115, 120, 55, 254])
      ),
      0
    )
  ) {
    return NftGifterInstruction.PurchaseTokens;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([29, 158, 252, 191, 10, 83, 219, 99])
      ),
      0
    )
  ) {
    return NftGifterInstruction.UpdateConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([145, 131, 74, 136, 65, 137, 42, 38])
      ),
      0
    )
  ) {
    return NftGifterInstruction.WithdrawSol;
  }
  throw new Error(
    'The provided instruction could not be identified as a nftGifter instruction.'
  );
}

export type ParsedNftGifterInstruction<
  TProgram extends string = '5gm1Nn7N3BDn2og4Umw5JePUhLUF2azKqwJduQx3tApg',
> =
  | ({
      instructionType: NftGifterInstruction.ClaimTokens;
    } & ParsedClaimTokensInstruction<TProgram>)
  | ({
      instructionType: NftGifterInstruction.InitConfig;
    } & ParsedInitConfigInstruction<TProgram>)
  | ({
      instructionType: NftGifterInstruction.MintNft;
    } & ParsedMintNftInstruction<TProgram>)
  | ({
      instructionType: NftGifterInstruction.PurchaseTokens;
    } & ParsedPurchaseTokensInstruction<TProgram>)
  | ({
      instructionType: NftGifterInstruction.UpdateConfig;
    } & ParsedUpdateConfigInstruction<TProgram>)
  | ({
      instructionType: NftGifterInstruction.WithdrawSol;
    } & ParsedWithdrawSolInstruction<TProgram>);
